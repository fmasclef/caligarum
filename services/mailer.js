/**
 * Mailer
 *
 * Generate email from EJS template,  then send it  using transports  defined in
 * the config file.  If multiple transports are defined,  use a random one.  You
 * should remove from config the transports you're not using. No transport means
 * no outgoing mail.
 */

var
  fs = require('fs'),
  mailcomposer = require('mailcomposer'),
  pug = require("pug")

module.exports = {

  /**
   * Cook an email based on a template and substitutions
   */
  prepare: (template, locals, options) => {
    locals = locals || {}
    locals.config = config
    locals.pjson = pjson
    Object.assign(locals, app.locals)
    // render both text and HTML versions
    let
      base = __dirname + '/../views/mail/',
      textSrc = (fs.existsSync(base + 'text/' + template + '.pug') ? base + 'text/' + template + '.pug' : base + 'text/_fallback.pug'),
      htmlSrc = (fs.existsSync(base + 'html/' + template + '.pug') ? base + 'html/' + template + '.pug' : base + 'html/_fallback.pug'),
      text = pug.renderFile(textSrc, locals),
      html = pug.renderFile(htmlSrc, locals)
    // create MIME message
    let mail = {
      mailopts: options,
      sender: config.mail.sender,
      from: config.mail.sender.name + ' <' + config.mail.sender.email + '>',
      to: options.to,
      subject: ('subject' in options) ? options.subject : 'A message from ' + pjson.name,
      text: text,
      html: html,
      attachments: [
        {
          filename: 'logo.png',
          path: 'static/images/mail/logo.png',
          cid: '3VR8aK6PKuA45J4BfmaH27X3mrB3m37C',
          type: 'image/png',
        }
      ]
    }
    return mail
  },

  /**
   * Actually send an email using a transport as defined in config file
   */
  send: (mail) => {
    // select a transport
    let
      options = mail.mailopts,
      transport = null,
      count = 0
    if (Object.getOwnPropertyNames(config.mail.transport).length !== 0) {
      let keys = Object.keys(config.mail.transport)
      transport = keys[ keys.length * Math.random() << 0]
    }
    if (transport == null)
      return;

    // send using the right transport
    winston.info('sending mail with %s', transport)
    switch (transport) {

      /**
       * provider: mailgun
       * The connector accepts contents generated by mailcomposer. We just have
       * to build & send
       */
      case "mailgun":
        mail = mailcomposer(mail)
        let
          mailgun = require('mailgun-js')({
          apiKey: config.mail.transport.mailgun.key,
          domain: config.mail.transport.mailgun.domain,
          proxy: config.server.proxy || ''
        })
        mail.build((err, message) => {
          if (err) {
            winston.error(err)
          } else {
            var data = {
              to: options.to,
              message: message.toString('ascii')
            }
            mailgun.messages().sendMime(data, function (error, body) {
              if (error) {
                winston.warn(error);
              } else {
                winston.debug(body);
              }
            })
          }
        })
        break

      /**
       * provider: mailjet
       * This client needs some camel-case JSON. Inline images must be base64
       * encoded prior using this transport.
       */
      case "mailjet":
        let
          mailjet = require('node-mailjet').connect(
            config.mail.transport.mailjet.key,
            config.mail.transport.mailjet.secret,
            {
              proxyUrl: config.server.proxy || '',
              timeout: 60000 // 1 minute
            })
        // prepare inline attachments
        let Inline_attachments = []
        for (a of mail.attachments) {
          let im = {
            "Filename": a.cid,
            "Content-type": a.type,
            "content": Helpers.file2base64(basePath + '/' + a.path)
          }
          Inline_attachments.push(im)
        }
        // send the mail
        let
          request = mailjet.post('send'),
          emailData = {
            "FromEmail": mail.sender.email,
            "FromName": mail.sender.name,
            "Subject": mail.subject,
            "Text-part": mail.text,
            "Html-part": mail.html,
            "Recipients": [
              { "Email": options.to }
            ],
            "Inline_attachments": Inline_attachments
          }
        request.request(emailData)
          .then(result => {
            winston.debug(result.body)
          })
          .catch(error => {
            winston.error(error)
          })
        break

      /**
       * provider: sendgrid
       * SendGrid use a JSON object to describe emails. This JSON is somewhat
       * different from the nodemailer format.
       */
      case "sendgrid":
        let
          sendgrid = require('sendgrid')(config.mail.transport.sendgrid.key)
        // prepare attachments
        let sgattachments = []
        for (a of mail.attachments) {
          let im = {
            filename: a.filename,
            type: a.type,
            disposition: 'inline',
            content_id: a.cid,
            content: Helpers.file2base64(basePath + '/' + a.path)
          }
          sgattachments.push(im)
        }
        // prepare the sendgrid request object
        let sgrequest = sendgrid.emptyRequest({
          method: 'POST',
          path: '/v3/mail/send',
          body: {
            personalizations: [
              {
                to: [
                  {
                    email: options.to
                  }
                ],
                subject: mail.subject
              }
            ],
            from: {
              email: mail.sender.email,
              name: mail.sender.name
            },
            content: [
              {
                type: 'text/plain',
                value: mail.text
              },
              {
                type: 'text/html',
                value: mail.html
              }
            ],
            attachments: sgattachments
          }
        })
        // send the mail
        sendgrid.API(sgrequest)
          .then(function (response) {
            winston.debug('sendgrid: %s', response.body)
          })
          .catch(function (error) {
            // error is an instance of SendGridError
            // The full response is attached to error.response
            winston.error('sendgrid: %s', error.response);
          });
        break

      /**
       * provider: sparkpost
       * The connector requires us to build a 'transmission'. We basically need
       * to pre-encode images to base64 and send them as a specific JSON array.
       */
      case "sparkpost":
        let
          SparkPost = require('sparkpost'),
          client = new SparkPost(config.mail.transport.sparkpost.key, {
            proxy: config.server.proxy || ''
          })
        // prepare 'inline images'
        let inline_images = []
        for (a of mail.attachments) {
          let im = {
            name: a.cid,
            type: a.type,
            data: Helpers.file2base64(basePath + '/' + a.path)
          }
          inline_images.push(im)
        }
        // send the mail
        client.transmissions.send({
          content: {
            from: mail.from,
            subject: mail.subject,
            html: mail.html,
            text: mail.text,
            inline_images: inline_images
          },
          recipients: [
            {address: options.to}
          ]
        })
        .then(data => {
          winston.debug(data)
        })
        .catch(err => {
          winston.error(err)
        })
        break
    }
  }
}
